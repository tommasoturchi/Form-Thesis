% !TEX root = ../my-thesis.tex
%
\pdfbookmark[0]{Abstract}{Abstract}
\chapter*{Abstract}
\label{sec:abstract}
\vspace*{-10mm}

Given how technology surrounds our whole life, learning to code is becoming more and more crucial for the general public: think for example of the amount of software involved in managing a flight, or when you just turn on the engine of your car. People want to play an increasingly active role in their life and there is already evidence in an overall heightened interest in coding: for instance, the Hour of Code\footnote{https://hourofcode.com} is a successful global initiative involving millions of students of different ages starting with 4-year old, aiming at introducing coding skills to a wide audience. Nonetheless, coding skills are not just about programming but require an ability of problem solving, abstraction, pattern recognition to name *some*; in a word, the so-called Computational Thinking skills. In her seminal work [@Wing:2006iz], Wing introduced Computational Thinking (CT) as a set of thinking skills, habits, and approaches that are integral to solving complex problems using a computer and widely applicable in today's information society.

Fostering the development of CT skills has recently become a focus of the End-User Development (EUD) research community [@Anonymous:2015iz], whose aim is to allow end users (i.e. any computer user) to adapt software systems to their particular needs at hand; it strives to enable them to exploit some of the computational capabilities enjoyed by professional programmers, thus to perform their tasks more efficiently and effectively (e.g. task automation). Computational Thinking, therefore, seems the ideal skill set needed to help the EUD community to reach its aim of lowering programming barriers and fostering its spread.

But at the same time, programming itself has proven to be an effective way of developing CT skills [@Orr:2009ip], thus current EUD techniques might have a similar effect on end users, although much discussion is still ongoing about how much this comes about and results are still inconclusive. <!-- This self-enforcing effect, given by the fact that CT skills are a fundamental requirement for coding but even fostered by it,-->

Certainly the use of Visual Languages is one of the most famous and well studied EUD technique with the aim of lowering the trickiest coding barrier, the often murky and complicated syntax: it encapsulates a programming language with a visual representation of each of its logical components, using graphical tweaks to make it easy to understand at a glance; for example, it might depict the available commands with different puzzle pieces that one can combine together to build a program, using different shapes to indicate which ones are compatible with each other, something that used to require training and experience to be fully grasped.

Another technique which takes a different approach in its endeavour to simplify coding is Programming by Demonstration (PbD) --- also known as Programming by Example [@2001:YWM:369505]: traditionally programs consist of a sequence of machine commands the system needs to execute to generate a specific result. PbD allows users to specify directly what the result should look like, that is by performing actions directly without the need of declaring the required system's behaviour using its syntax; the system itself will then figure out how to translate those actions into the right set of instructions. This paradigm is effective within domains such as the robots' programming context [@Billard:2008kb]: in order to teach a robot new movements, users can demonstrate them on the robot itself by twitching and stretching its joints to match the target behaviour, which the robot will learn and then perform autonomously. The benefit of PbD is that rather than having to learn an obscure programming language to automate their tasks, users can demonstrate programs using an interface they are already familiar with.

To summarise, both these techniques can lower coding barriers and enable end users to program with almost no training or expertise; since they act like a scaffold between the system interface and the programming environment, the benefits resulting from traditional coding on the development of CT skills might be naturally mediated by them.

Since its introduction in 2006, the whole research community has struggled to come up with an exact definition of what Computational Thinking encompasses. A recent survey [@Selby:2013vg] points out that the only consensus reached so far between the different proposed definitions pertains to the concepts of abstraction and decomposition:

- Abstraction is useful to make problems easier to reason about by hiding details, thus removing unnecessary complexity from them. Possessing this skill means being able to choose the right problem representation and level of analysis to place oneself, without losing any important detail about it.
- Decomposition refers to thinking about a problem (or --- more generally --- an artifact, e.g. a system, a process, or an algorithm) in terms of its components; one can then understand, solve and evaluate them separately, making the overall problem easier to solve.

These two concepts are an integral part of Computational Thinking, as well as frequently required during any programming task. Dealing with abstract concepts is often a challenge for inexperienced users, who usually need to train and practice this skill for a while before mastering it. By Piaget's constructivist theory [@Piaget:1969vq], this could be due to how human capabilities evolve during the first years of life: at ages 7 to 11 children are in what he called *concrete operational stage*; they can think logically in terms of objects, but have difficulty replacing them with symbols. Ultimately, they can solve problems in a logical fashion, but are typically not able to think abstractly or hypothetically. The following stage, i.e. the *formal operational stage*, enables them to replace objects with symbols, generalizing and manipulating abstract concepts by using proportional reasoning and deriving cause-effect relationships. The shift from concrete operational to formal operational should occur by age 12, but a later study [@Williams:1995vm] found that most College freshmen in physics courses still haven't made it, being incapable of grasping abstract concepts not firmly embedded in their concrete experience.

In the light of these considerations, we argue that exploiting our innate dexterity for objects' manipulation in the physical world could be an effective way of aiding concrete operational thinkers to grasp abstract concepts often involved by coding, thus fostering the development of Computational Thinking skills. Physical manipulation is an interaction paradigm currently employed in digital systems with the aim of providing users with an easy to use interface that even inexperienced people can use; this paradigm goes under the name of Tangible User Interfaces (TUIs) [@Ishii:1997gy]. Employing a TUI in an End-User Development system --- thus pairing it up with a technique with the aim of lowering programming barriers and allowing end users to program --- could foster their Computational Thinking skills by supporting them with a concrete representation of the abstract concepts they have to deal with.

\emph{How does employing a Tangible User Interface on top of an EUD technique affect the development of Computational Thinking skills?}